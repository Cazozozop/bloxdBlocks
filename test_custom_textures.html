<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Test Exceptions BloxdBlocks</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    background: #1a1a1a;
    color: #fff;
    text-align: center;
    padding: 30px;
  }
  input {
    font-size: 18px;
    padding: 10px;
    border-radius: 8px;
    border: none;
    width: 80%;
    max-width: 400px;
    margin-bottom: 20px;
  }
  .result {
    margin-top: 20px;
  }
  img {
    image-rendering: pixelated;
    width: 96px;
    height: 96px;
    margin: 5px;
    border-radius: 6px;
    background: #333;
  }
  .error {
    color: #ff6b6b;
  }
</style>
</head>
<body>
<h1>üîç Test Exceptions BloxdBlocks</h1>
<input type="text" id="search" placeholder="Tape un nom de bloc...">
<div class="result" id="result">Chargement...</div>

<script>
const CUSTOM_TEXTURE_BASE = "https://raw.githubusercontent.com/Cazozozop/bloxdBlocks/refs/heads/main/";

async function loadExceptions() {
  const url = CUSTOM_TEXTURE_BASE + "exceptions.txt";
  document.getElementById("result").innerHTML = "Chargement des exceptions...";
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error("HTTP " + res.status);
    const txt = await res.text();

    const out = {};

    // ‚úÖ Capte chaque mapping m√™me sur la m√™me ligne
    const pattern = /"([^"]+)"\s*=\s*(".*?(?=(?:"\s*=)|$))/g;
    let match;
    while ((match = pattern.exec(txt)) !== null) {
      const blockNameRaw = match[1].trim();
      const texturePart = match[2].trim();

      // plusieurs blocs possibles : "a|b"
      const blockNames = blockNameRaw.split('|').map(n => n.trim());

      // extraire textures entre guillemets
      const texMatches = [...texturePart.matchAll(/"([^"]+)"/g)].map(m => m[1]);

      // intervalle facultatif ex : :200
      const intervalMatch = texturePart.match(/:(\d+)\s*$/);
      const interval = intervalMatch ? parseInt(intervalMatch[1]) : 100;

      for (const bn of blockNames) {
        out[bn] = {
          textures: texMatches,
          animated: texMatches.length > 1,
          interval
        };
      }
    }

    const count = Object.keys(out).length;
    document.getElementById("result").innerHTML = `‚úÖ Exceptions charg√©es (${count})`;
    return out;
  } catch (e) {
    document.getElementById("result").innerHTML = `<span class='error'>‚ùå Erreur: ${e.message}</span>`;
    return {};
  }
}

let exceptions = {};
(async () => { exceptions = await loadExceptions(); })();

document.getElementById("search").addEventListener("input", e => {
  const val = e.target.value.trim();
  const out = document.getElementById("result");
  if (!val) { out.innerHTML = "..."; return; }
  const found = exceptions[val];
  if (!found) {
    out.innerHTML = `<span class='error'>Aucune exception trouv√©e pour <b>${val}</b>.</span>`;
    return;
  }
  let html = `<h2>${val}</h2>`;
  html += `<p>Textures : ${found.textures.join(", ")}</p>`;
  html += `<p>Intervalle : ${found.interval} ms</p>`;
  for (const tex of found.textures) {
    const url = CUSTOM_TEXTURE_BASE + tex + ".png";
    html += `<img src="${url}" alt="${tex}" onerror="this.style.display='none'">`;
  }
  out.innerHTML = html;
});
</script>
</body>
</html>
